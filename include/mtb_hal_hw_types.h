/***************************************************************************//**
* \file mtb_hal_hw_types.h
*
* \brief
* Provides a struct definitions for configuration resources in the PDL.
*
********************************************************************************
* \copyright
* Copyright 2018-2022 Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation
*
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

/**
 * \addtogroup group_hal_impl Implementation Specific
 * \{
 * This section provides details about the implementation of the Infineon HAL.
 * All information within this section is platform specific and is provided for reference.
 * Portable application code should depend only on the APIs and types which are documented
 * in the @ref group_hal section.
 *
 * \section group_hal_impl_mapping HAL Resource Hardware Mapping
 * The following table shows a mapping of each HAL driver to the lower level firmware driver
 * and the corresponding hardware resource. This is intended to help understand how the HAL
 * is implemented and what features the underlying hardware supports.
 *
 * | HAL Resource       | PDL Driver(s)       | Hardware                         |
 * | ------------------ | ------------------- | -------------------------------- |
 * | ADC                | cy_adc              | SAR ADC                          |
 * | Clock              | cy_sysclk           | All clocks (system & peripheral) |
 * | Comparator         | cy_ctb or cy_lpcomp | CTBm or LPComp                   |
 * | DMA                | cy_dma, cy_dmac     | DMA Controller                   |
 * | NVM                | cy_flash            | Flash                            |
 * | GPIO               | cy_gpio             | GPIO                             |
 * | I2C                | cy_scb_i2c          | SCB                              |
 * | LPTimer            | cy_mcwdt            | MCWDT                            |
 * | PWM                | cy_pwm              | TCPWM                            |
 * | MemorySPI          | cy_smif             | MemorySPI (SMIF)                 |
 * | RTC                | cy_rtc              | RTC                              |
 * | SDHC               | cy_sd_host          | SD Host                          |
 * | SDIO               | cy_sd_host, or NA   | SD Host, or UDB                  |
 * | SPI                | cy_scb_spi          | SCB                              |
 * | SysPM              | cy_syspm            | System Power Resources           |
 * | System             | cy_syslib           | System Resources                 |
 * | Timer              | cy_tcpwm_counter    | TCPWM                            |
 * | TRNG               | cy_crypto_core_trng | Crypto                           |
 * | UART               | cy_scb_uart         | SCB                              |
 *
 * \section group_hal_impl_errors Device Specific Errors
 * Error codes generated by the low level level PDL driver all use module IDs starting
 * with \ref CY_RSLT_MODULE_DRIVERS_PDL_BASE. The exact errors are documented for each
 * driver in the
 * <a href="https://infineon.github.io/mtb-pdl-cat1/pdl_api_reference_manual/html/index.html">
 * mtb-pdl-cat1 documentation</a>.
 */

/**
 * \addtogroup group_hal_impl_hw_types Specific Hardware Types
 * \{
 * Aliases for types which are part of the public HAL interface but whose representations
 * need to vary per HAL implementation
 */

#pragma once

#include "cy_pdl.h"
#include "mtb_hal_general_types.h"
#include "mtb_hal_hw_resources.h"
#include "mtb_hal_irq_impl.h"
#include <stdbool.h>

#if defined(MTB_HAL_UDB_SDIO)
    #include "SDIO_HOST.h"
#endif

#if defined(COMPONENT_MW_ASYNC_TRANSFER)
#include "mtb_async_transfer.h"
#endif // defined(COMPONENT_MW_ASYNC_TRANSFER)

#ifdef __cplusplus
extern "C" {
#endif

#if defined(COMPONENT_SECURE_DEVICE) || defined(CY_PDL_TZ_ENABLED)
/* Define if the image is secure or non-secure */
#define _MTB_HAL_IMAGE_TYPE_SECURE
#endif

/**
 * \cond INTERNAL
 */

//! IP-specific implementation header for ADC
#define MTB_HAL_ADC_IMPL_HEADER           "mtb_hal_adc_impl.h"
// Implementation specific header for Clock
#define MTB_HAL_CLOCK_IMPL_HEADER         "mtb_hal_clock_impl.h"
//! IP-specific implementation header for Comp
#define MTB_HAL_COMP_IMPL_HEADER          "mtb_hal_comp_impl.h"
// Implementation specific header for DMA
#define MTB_HAL_DMA_IMPL_HEADER           "mtb_hal_dma_impl.h"
//! Implementation specific header for GPIO
#define MTB_HAL_GPIO_IMPL_HEADER          "mtb_hal_gpio_impl.h"
//! Implementation specific header for I2C
#define MTB_HAL_I2C_IMPL_HEADER           "mtb_hal_i2c_impl.h"
//! Implementation header for LPTimer
#define MTB_HAL_LPTIMER_IMPL_HEADER       "mtb_hal_lptimer_impl.h"
//! Implementation specific header for NVM
#define MTB_HAL_NVM_IMPL_HEADER           "mtb_hal_nvm_impl.h"
//! Implementation specific header for RTC
#define MTB_HAL_RTC_IMPL_HEADER           "mtb_hal_rtc_impl.h"
//! Implementation specific header for SPI
#define MTB_HAL_SPI_IMPL_HEADER           "mtb_hal_spi_impl.h"
//! Implementation specific header for SysPm
#define MTB_HAL_SYSPM_IMPL_HEADER        "mtb_hal_syspm_impl.h"
//! Implementation specific header for System
#define MTB_HAL_SYSTEM_IMPL_HEADER        "mtb_hal_system_impl.h"
//! Implementation specific header for Timer
#define MTB_HAL_TIMER_IMPL_HEADER         "mtb_hal_timer_impl.h"
//! Implementation specific header for TRNG
#define MTB_HAL_TRNG_IMPL_HEADER          "mtb_hal_trng_impl.h"
//! Implementation specific header for UART
#define MTB_HAL_UART_IMPL_HEADER          "mtb_hal_uart_impl.h"

/** \endcond */

/** @brief Event callback data object */
typedef struct
{
    cy_israddress                       callback;
    void*                               callback_arg;
} mtb_hal_event_callback_data_t;

/**
 * @brief Store information about buffer
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    union
    {
        void*       v;
        uint8_t*    u8;
        uint16_t*   u16;
        uint32_t*   u32;
    } addr;
    uint32_t size;
} _mtb_hal_buffer_info_t;

/**
 * @brief Connection type definition
 *
 * Represents an association between gpio and pin port numbers
 */
typedef struct
{
    uint8_t                               pin_num;        //!< The associated gpio pin number
    uint8_t                               port_num;       //!< The associated gpio port number
    GPIO_PRT_Type*                        port_addr;      //!< The associated gpio port address
    mtb_hal_event_callback_data_t         callback_data;  //!< The callback data associated with the
                                                          //!< pin
} mtb_hal_gpio_t;

/**
 * @brief GPIO Port object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef GPIO_PRT_Type* mtb_hal_gpio_port_t;

/**
 * @brief Shared TCPWM data between timer/counter and PWM
 *
 * Application code should not rely on the specific content of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #ifdef CY_IP_MXTCPWM
    TCPWM_Type*                         base;         //!< The base address pointer of the TCPWM
                                                      //!< resource
    uint32_t                            group;        //!< The associated group number
    uint32_t                            cntnum;       //!< The associated counter number
    uint32_t                            max_count;    //!< The max count for the counter
    const mtb_hal_clock_t*              clock;        //!< The associated clock resource pointer
    uint32_t                            clock_hz;     //!< The associated clock frequency
    #else // ifdef CY_IP_MXTCPWM
    void* empty;
    #endif // ifdef CY_IP_MXTCPWM
} mtb_hal_tcpwm_t;

/** DMA type */
typedef enum
{
    MTB_HAL_DMA_DW = 0,
    MTB_HAL_DMA_DMAC = 1
} mtb_hal_dma_type_t;

/* This is presented out of order because many other structs depend on it */
/**
 * @brief DMA object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) || defined(CY_IP_M4CPUSS_DMA) || \
    defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXAHBDMAC) || defined(CY_IP_MXDW) || \
    defined(CY_IP_MXSAXIDMAC)
    union
    {
        #if defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXDW)
        cy_stc_dma_descriptor_t*             dw;
        #endif
        #if defined(CY_IP_MXSAXIDMAC)
        cy_stc_axidmac_descriptor_t*         dmac;
        #elif defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) || defined(CY_IP_MXAHBDMAC)
        cy_stc_dmac_descriptor_t*            dmac;
        #endif
    } descriptor;
    union
    {
        #if defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXDW)
        DW_Type*                             dw_base;
        #endif
        #if defined(CY_IP_MXSAXIDMAC)
        AXI_DMAC_Type*                       dmac_base;
        #elif defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) || defined(CY_IP_MXAHBDMAC)
        DMAC_Type*                           dmac_base;
        #endif
    } base;
    mtb_hal_dma_type_t                       dma_type;
    uint32_t                                 channel;
    uint16_t                                 expected_bursts;
    uint32_t                                 direction; /* really a mtb_hal_dma_direction_t */
    uint32_t                                 irq_cause;
    mtb_hal_event_callback_data_t            callback_data;
    #else // if defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) ||
    // defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXAHBDMAC) ||
    // defined(CY_IP_MXDW) || defined(CY_IP_MXSAXIDMAC)
    void* empty;
    #endif // if defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) ||
    // defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXAHBDMAC)
    // || defined(CY_IP_MXDW) || defined(CY_IP_MXSAXIDMAC)
} mtb_hal_dma_t;

/**
 * @brief DMA configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    mtb_hal_dma_type_t                       dma_type;
    uint32_t                                 channel;
    struct
    {
        union
        {
            #if defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXDW)
            DW_Type const*                    dw_base;
            #endif
            #if defined(CY_IP_MXSAXIDMAC)
            /* AXI DMA controller has a 64-bit AXI master interface */
            AXI_DMAC_Type  const*             dmac_base;
            #elif defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) || \
            defined(CY_IP_MXAHBDMAC)
            DMAC_Type const*                  dmac_base;
            #endif
        };

        union
        {
            #if defined(CY_IP_M4CPUSS_DMA) || defined(CY_IP_M7CPUSS_DMA) || defined(CY_IP_MXDW)
            cy_stc_dma_descriptor_t*          dw_descriptor;
            #endif
            #if defined(CY_IP_MXSAXIDMAC)
            cy_stc_axidmac_descriptor_t*      dmac_descriptor;
            #elif defined(CY_IP_M4CPUSS_DMAC) || defined(CY_IP_M7CPUSS_DMAC) || \
            defined(CY_IP_MXAHBDMAC)
            cy_stc_dmac_descriptor_t*         dmac_descriptor;
            #endif
        };
    };
} mtb_hal_dma_configurator_t;

struct _mtb_hal_adc_channel_s;

/* Maximum number of channels across all ADC instances. For XMC7, we have to compute this */
#if defined(CY_IP_MXS40EPASS_ESAR)
    #if (((CY_IP_MXS40EPASS_ESAR_INSTANCES < 2) || \
    (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR > PASS_SAR_SLICE_NR1_SAR_SAR_CHAN_NR)) \
    && ((CY_IP_MXS40EPASS_ESAR_INSTANCES < 3) || \
    (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR > PASS_SAR_SLICE_NR2_SAR_SAR_CHAN_NR)))
        #define CY_SAR_MAX_NUM_CHANNELS (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR)
    #elif ((CY_IP_MXS40EPASS_ESAR_INSTANCES < 2) /* If we got to this point, we know neither 0 isn't
                                                    the max */ \
    && (CY_IP_MXS40EPASS_ESAR_INSTANCES < 3 || \
        (PASS_SAR_SLICE_NR1_SAR_SAR_CHAN_NR > PASS_SAR_SLICE_NR2_SAR_SAR_CHAN_NR)))
        #define CY_SAR_MAX_NUM_CHANNELS (PASS_SAR_SLICE_NR1_SAR_SAR_CHAN_NR)
    #elif (CY_IP_MXS40EPASS_ESAR_INSTANCES < 4) /* If we got to this point, we know neither 0 nor 1
                                                   is the max */
        #define CY_SAR_MAX_NUM_CHANNELS (PASS_SAR_SLICE_NR2_SAR_SAR_CHAN_NR)
    #else // if (((CY_IP_MXS40EPASS_ESAR_INSTANCES < 2) || (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR >
// PASS_SAR_SLICE_NR1_SAR_SAR_CHAN_NR)) && ((CY_IP_MXS40EPASS_ESAR_INSTANCES < 3) ||
// (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR > PASS_SAR_SLICE_NR2_SAR_SAR_CHAN_NR)))
        #error "Unhandled ADC instance count"
    #endif // if (((CY_IP_MXS40EPASS_ESAR_INSTANCES < 2) || (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR >
// PASS_SAR_SLICE_NR1_SAR_SAR_CHAN_NR)) && ((CY_IP_MXS40EPASS_ESAR_INSTANCES < 3) ||
// (PASS_SAR_SLICE_NR0_SAR_SAR_CHAN_NR > PASS_SAR_SLICE_NR2_SAR_SAR_CHAN_NR)))
#elif defined(CY_IP_MXS22LPPASS_SAR)
    #define CY_SAR_MAX_NUM_CHANNELS (PASS_SAR_SAR_GPIO_CHANNELS)
#elif defined(CY_IP_MXS40MCPASS)
    #define CY_SAR_MAX_NUM_CHANNELS (CY_HPPASS_SAR_DIR_SAMP_NUM + CY_HPPASS_SAR_MUX_SAMP_NUM)
#endif // if defined(CY_IP_MXS40EPASS_ESAR)

/**
 * @brief ADC object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if (_MTB_HAL_DRIVER_AVAILABLE_ADC_SAR > 0)
    struct _mtb_hal_adc_channel_s*      channel_config[CY_SAR_MAX_NUM_CHANNELS];
    #endif // (_MTB_HAL_DRIVER_AVAILABLE_ADC_SAR > 0)
    #if defined(CY_IP_MXS40PASS_SAR)
    SAR_Type*                           base;
    #elif defined(CY_IP_MXS40EPASS_ESAR)
    PASS_SAR_Type*                      base;
    #elif defined(CY_IP_MXS22LPPASS_SAR)
    /* Intentionally no base pointer, unnecessary for this IP */
    #elif defined(CY_IP_MXS40MCPASS)
    HPPASS_Type*                        base;
    uint32_t                            enabled_channels;
    uint32_t                            enabled_groups;
    uint32_t                            enabled_triggers;
    uint32_t                            enabled_diff;
    uint32_t                            enabled_average;
    #elif defined(CY_IP_MXS40ADCMIC)
    MXS40ADCMIC_Type*                   base;
    #endif // various ADC IPs
    const mtb_hal_clock_t*              clock;
    bool                                continuous_scanning;
} mtb_hal_adc_t;


/**
 * @brief ADC configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXS40PASS_SAR)
    SAR_Type*                           base;
    cy_stc_sar_config_t const*          config;
    #elif defined(CY_IP_MXS40EPASS_ESAR)
    PASS_SAR_Type*                      base;
    cy_stc_sar2_config_t const*         config;
    #elif defined(CY_IP_MXS22LPPASS_SAR)
    /* Intentionally no base pointer, unnecessary for this IP */
    cy_stc_autanalog_sar_t*             config;
    #elif defined(CY_IP_MXS40MCPASS)
    HPPASS_Type*                        base;
    cy_stc_hppass_cfg_t const*          hppass_config;
    #elif defined(CY_IP_MXS40ADCMIC)
    MXS40ADCMIC_Type*                   base;
    cy_stc_adcmic_config_t const*       config;
    #endif // various ADC IPs
    const mtb_hal_clock_t*              clock;
    uint8_t                             num_channels;
} mtb_hal_adc_configurator_t;

/**
 * @brief ADC channel object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct _mtb_hal_adc_channel_s   /* Struct given an explicit name to make the forward
                                           declaration above work */
{
    #if defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS40EPASS_ESAR) || \
    defined(CY_IP_MXS40ADCMIC_INSTANCES) || defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) || \
    defined(CY_IP_MXS40MCPASS_INSTANCES)
    mtb_hal_adc_t*                      adc;
    uint8_t                             channel_idx;
    uint8_t                             channel_msk;
    #if defined(CY_IP_MXS40ADCMIC_INSTANCES)
    /* ADCMIC only supports single-ended channels at a fixed sample rate */
    cy_en_adcmic_dc_channel_t           channel_sel;
    bool                                enabled;
    #elif defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS40EPASS_ESAR) || \
    defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) || defined(CY_IP_MXS40MCPASS_INSTANCES)
    #if defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) || \
    defined(CY_IP_MXS40MCPASS)
    #if defined(CY_IP_MXS22LPPASS_SAR_INSTANCES)
    // Whenever we change one channel, the PDL needs to reapply configuration to all of the
    // channels. So keep track of our PDL config struct so that we can have stable pointers
    // in the channel config array
    cy_stc_autanalog_sar_hs_chan_t      pdl_cfg;
    uint8_t                             gpioNum; // GPIO Mux channel to which this pin is connected
    #endif
    #elif defined(CY_IP_MXS40EPASS_ESAR_INSTANCES)
    bool                                avg_enabled;
    #endif // if defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) ||
    // defined(CY_IP_MXS40MCPASS)
    /* EPASS only supports single-ended channels */
    uint32_t                            minimum_acquisition_ns;
    #endif // if defined(CY_IP_MXS40ADCMIC_INSTANCES)
    #if defined(CY_IP_MXS40MCPASS_INSTANCES)
    bool                                diff;
    #endif
    #else // if defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS40EPASS_ESAR) ||
    // defined(CY_IP_MXS40ADCMIC_INSTANCES) || defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) ||
    // defined(CY_IP_MXS40MCPASS_INSTANCES)
    void* empty;
    #endif // if defined(CY_IP_MXS40PASS_SAR) || defined(CY_IP_MXS40EPASS_ESAR) ||
    // defined(CY_IP_MXS40ADCMIC_INSTANCES) || defined(CY_IP_MXS22LPPASS_SAR_INSTANCES) ||
    // defined(CY_IP_MXS40MCPASS_INSTANCES)
} mtb_hal_adc_channel_t;

/** @brief Comparator object */
typedef struct
{
    #if defined(CY_IP_MXLPCOMP_INSTANCES) || defined (CY_IP_MXS40LPCOMP_INSTANCES) || \
    defined(CY_IP_MXS40PASS_CTB_INSTANCES) || defined (CY_IP_MXS22LPCOMP_INSTANCES) || \
    defined(CY_IP_MXS40MCPASS_INSTANCES)
    mtb_hal_resource_t comp_type;
    union
    {
        #if defined(CY_IP_MXS40PASS_CTB_INSTANCES)
        CTBM_Type*   base_ctb;
        #endif
        #if defined(CY_IP_MXLPCOMP_INSTANCES) || defined (CY_IP_MXS22LPCOMP_INSTANCES) || \
        defined (CY_IP_MXS40LPCOMP_INSTANCES)
        LPCOMP_Type* base_lpcomp;
        #endif
    };

    #if defined(CY_IP_MXS22LPPASS_PTC_INSTANCES)
    struct
    {
        cy_en_autanalog_ptcomp_comp_hyst_t ptc_hysteresis_enabled;
        cy_en_autanalog_ptcomp_comp_pwr_t  ptc_power;
        // We need to store the actual pin mux values in addition to the
        // mtb_hal_gpio_t values below because we don't necessarily know
        // what the GPIOs are in the configurator init case
        cy_en_autanalog_ptcomp_comp_mux_t  ptc_input_plus;
        cy_en_autanalog_ptcomp_comp_mux_t  ptc_input_minus;
    };

    #endif // if defined(CY_IP_MXS22LPPASS_PTC_INSTANCES)

    #if defined (CY_IP_MXS40LPCOMP_INSTANCES)
    cy_en_lpcomp_channel_t              channel;
    #endif

    #if defined(CY_IP_MXS40MCPASS_INSTANCES)
    uint8_t                             slice;
    #endif
    #if defined(COMPONENT_MTB_PWRLIB_ENABLE)
    mtb_hal_event_callback_data_t       callback_data;
    uint32_t                            callback_event;
    #endif
    #else // if defined(CY_IP_MXLPCOMP_INSTANCES) || defined (CY_IP_MXS40LPCOMP_INSTANCES) ||
    // defined(CY_IP_MXS40PASS_CTB_INSTANCES) || defined (CY_IP_MXS22LPCOMP_INSTANCES) ||
    // defined(CY_IP_MXS40MCPASS_INSTANCES)
    void* empty;
    #endif // if defined(CY_IP_MXLPCOMP_INSTANCES) || defined (CY_IP_MXS40LPCOMP_INSTANCES) ||
    // defined(CY_IP_MXS40PASS_CTB_INSTANCES) || defined (CY_IP_MXS22LPCOMP_INSTANCES) ||
    // defined(CY_IP_MXS40MCPASS_INSTANCES)
} mtb_hal_comp_t;

/**
 * @brief Comp configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    mtb_hal_resource_t resource_type;
    uint8_t            channel_num;
    #if (((CY_IP_MXS40MCPASS_INSTANCES) > 0) || ((CY_IP_MXLPCOMP_INSTANCES) > 0) || \
    ((CY_IP_MXS40LPCOMP_INSTANCES) > 0) \
    || (((CY_IP_MXS40PASS_INSTANCES) > 0) && ((CY_IP_MXS40PASS_CTB_INSTANCES) > 0)) \
    || (((CY_IP_MXS22LPPASS_INSTANCES) > 0) && ((CY_IP_MXS22LPPASS_CTB_INSTANCES) > 0)))
    union
    {
        #if ((CY_IP_MXS40MCPASS_INSTANCES) > 0)
        const cy_stc_hppass_cfg_t* hppass_config;       /* Contains SAR instance within it */
        #endif
        #if ((CY_IP_MXLPCOMP_INSTANCES) > 0) || ((CY_IP_MXS40LPCOMP_INSTANCES) > 0)
        const cy_stc_lpcomp_config_t* lpcomp;
        #endif
        #if (((CY_IP_MXS40PASS_INSTANCES) > 0) && ((CY_IP_MXS40PASS_CTB_INSTANCES) > 0))
        const cy_stc_ctb_opamp_config_t* opamp;
        #elif (((CY_IP_MXS22LPPASS_INSTANCES) > 0) && ((CY_IP_MXS22LPPASS_CTB_INSTANCES) > 0))
        struct
        {
            const cy_stc_autanalog_ctb_sta_t*           static_cfg;
            const cy_stc_autanalog_ctb_dyn_t*           dynamic_cfg;
            uint32_t                                    dynamic_cfg_num;
        };

        #endif
        #if _MTB_HAL_DRIVER_AVAILABLE_COMP_PTC
        cy_stc_autanalog_ptcomp_t* ptc;
        #endif
    };

    #endif \
    /* defined(CY_IP_MXS40MCPASS) || defined(CY_IP_MXLPCOMP) || (((CY_IP_MXS40PASS_INSTANCES) > 0)
       && ((CY_IP_MXS40PASS_CTB_INSTANCES) > 0)) */
    /* No GPIOs specified. The configurator could have routed from a non-preferred
     * GPIO, or from another non-GPIO on-chip source. */
} mtb_hal_comp_configurator_t;

/**
 * @brief CORDIC object
 *
 * Application code should not rely on the specific content of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXCORDIC)
    MXCORDIC_Type*                      base;
    cy_stc_cordic_context_t             context;
    mtb_hal_event_callback_data_t       callback_data;
    uint32_t                            irq_cause;
    #else /* defined(CY_IP_MXCORDIC) */
    void* empty;
    #endif /* defined(CY_IP_MXCORDIC) */
} mtb_hal_cordic_t;

/**
 * @brief NVM configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    void* empty;
} mtb_hal_nvm_configurator_t;

/**
 * @brief NVM object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    void* empty;
} mtb_hal_nvm_t;

/**
 * @brief I2C object
 *
 * Application code should not rely on the specific contents of this staruct.
 * They are considered an implementation detail which is subject to chnge
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                         base;
    cy_stc_scb_i2c_context_t*           context;
    const mtb_hal_clock_t*              clock;
    mtb_hal_event_callback_data_t       callback_data;
    mtb_hal_event_callback_data_t       addr_callback_data;
    uint32_t                            irq_cause;
    uint8_t                             addr_irq_cause;
    bool                                op_in_callback;
    _mtb_hal_buffer_info_t              rx_target_buff;
    _mtb_hal_buffer_info_t              tx_target_buff;
    // I2C reconfigures at run-time using this structure, so keep track of it
    const cy_stc_scb_i2c_config_t*      config;
    #else // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    void* empty;
    #endif // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
} mtb_hal_i2c_t;

/**
 * @brief I2C configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                     base;
    const cy_stc_scb_i2c_config_t*  config;
    const mtb_hal_clock_t*          clock;
    #else
    void* empty;
    #endif /* defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB) */
} mtb_hal_i2c_configurator_t;

/** @brief IPC object */
typedef struct mtb_hal_ipc_s
{
    #if defined(IPC) || defined(CY_IP_MXIPC)
    bool                                sema_preemptable;   //!< if true, allow preemption
    uint32_t                            sema_number;        //!< semaphore number in IPC system
    volatile int32_t                    sema_taken;         //!< != 0 means taken
    struct mtb_hal_ipc_queue_s*         queue_obj;          //!< if != NULL, this object
                                                            //!< associated with a HAL IPC Queue
    struct mtb_hal_ipc_s*               next_sema;          //!< Next semaphore in singly linked
                                                            //!< list
    #else
    void* empty;
    #endif
} mtb_hal_ipc_t;

/**
 * @brief HAL IPC notification info
 *
 * IPC Notification and callback information per Process associated with one Queue.
 */
typedef struct _mtb_hal_ipc_queue_process_info_s
{
    #if (MTB_HAL_DRIVER_AVAILABLE_IPC)
    uint32_t                        mask;                   //!< Process-specific notification mask
                                                            //!< for this Queue
    uint32_t                        flags;                  //!< Process-specific active
                                                            //!< notification flags for this Queue
    void*                           cb;                     //!< Process callback function
                                                            //!< mtb_hal_ipc_event_callback_t
    void*                           arg;                    //!< Process callback argument (opaque
                                                            //!< to HAL IPC)
    mtb_hal_ipc_t                   notification_semaphore; //!< IPC semaphore for changing data
                                                            //!< in this notification structure
    bool                            sema_valid;             //!< Semaphore created
    #else // if (MTB_HAL_DRIVER_AVAILABLE_IPC)
    void* empty;
    #endif /* (MTB_HAL_DRIVER_AVAILABLE_IPC) */
} _mtb_hal_ipc_queue_process_info_t;

/**
 * @brief LPTIMER object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined (CY_IP_MXS28SRSS) || defined (CY_IP_MXS40SSRSS) || defined (CY_IP_MXS40SRSS) || \
    defined (CY_IP_MXS22SRSS)
    #if (defined (CY_IP_MXS40SRSS) && (CY_IP_MXS40SRSS_VERSION >= 2))
    MCWDT_Type*                         base;
    cy_en_mcwdtctr_t                    counter;
    volatile uint32_t                   offset;
    volatile uint32_t                   final_time;
    #else
    MCWDT_STRUCT_Type*                  base;
    #endif
    mtb_hal_event_callback_data_t       callback_data;
    bool                                clear_int_mask;
    uint8_t                             isr_instruction;
    #else \
    // if (defined (CY_IP_MXS28SRSS) || defined (CY_IP_MXS40SSRSS) || defined (CY_IP_MXS40SRSS) ||
    // defined (CY_IP_MXS22SRSS))
    void* empty;
    #endif \
    /* (defined (CY_IP_MXS28SRSS) || defined (CY_IP_MXS40SSRSS) || defined (CY_IP_MXS40SRSS) ||
       defined (CY_IP_MXS22SRSS)) */
} mtb_hal_lptimer_t;

/**
 * @brief Lptimer configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if (defined (CY_IP_MXS40SRSS) && (CY_IP_MXS40SRSS_VERSION >= 2))
    MCWDT_Type*                         base;
    #elif defined (CY_IP_MXS28SRSS) || defined (CY_IP_MXS40SSRSS) || defined (CY_IP_MXS40SRSS) || \
    defined (CY_IP_MXS22SRSS)
    MCWDT_STRUCT_Type*                  base;
    #else
    void* empty;
    #endif
} mtb_hal_lptimer_configurator_t;

/**
 * @brief PWM object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #ifdef CY_IP_MXTCPWM
    mtb_hal_tcpwm_t                     tcpwm;
    #if defined(COMPONENT_MTB_PWRLIB_ENABLE)
    mtb_hal_event_callback_data_t       callback_data;
    uint32_t                            callback_event;   //!< Event requested
    #endif
    #else // ifdef CY_IP_MXTCPWM
    void* empty;
    #endif // ifdef CY_IP_MXTCPWM
} mtb_hal_pwm_t;

/**
 * @brief PWM configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXTCPWM) || defined(CY_IP_MXS40TCPWM)
    TCPWM_Type*             base;      //!< TCPWM base
    uint32_t                group;     //!< The resource group index
    uint32_t                cntnum;    //!< The resource counter index
    uint32_t                max_count; //!< The max count for the counter
    const mtb_hal_clock_t*  clock;     //!< The clock resource pointer
    #else
    void* empty;
    #endif /* defined(CY_IP_MXTCPWM) || defined(CY_IP_MXS40TCPWM) */
} mtb_hal_pwm_configurator_t;

/**
 * @brief MemorySPI object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #ifdef CY_IP_MXSMIF
    SMIF_Type*                          base;
    /* Active chip select */
    cy_en_smif_slave_select_t           chip_select;
    /* All configured chip selects */
    uint32_t                            configured_csel;
    uint32_t                            instNumber;
    cy_stc_smif_context_t               context;
    uint32_t                            enabled_events;
    mtb_hal_event_callback_data_t       callback_data;
    const mtb_hal_clock_t*              clock;
    #else // ifdef CY_IP_MXSMIF
    void* empty;
    #endif /* ifdef CY_IP_MXSMIF */
} mtb_hal_memoryspi_t;

/**
 * @brief MemorySPI configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #ifdef CY_IP_MXSMIF
    SMIF_Type*                              base;
    const cy_stc_smif_config_t*             config;
    uint32_t                                instNumber;
    cy_stc_smif_context_t                   context;
    const mtb_hal_clock_t*                  clock;
    bool                                    csel[4];
    /* Bit representation of currently not supported interrupts:
        Bit 5 : Memory Mode Alignment Error
        Bit 4 : RX Data FIFO Underflow
        Bit 3 : TX Command FIFO Overflow
        Bit 2 : TX Data FIFO Overflow
        Bit 1 : RX FIFO Level Trigger
        Bit 0 : TX FIFO Level Trigger
     */
    uint8_t                                 irqs;
    /* Bit representation of DMA triggers activation indicators:
        Bit 1 : RX Trigger Output activated in configurator
        Bit 0 : TX Trigger Output activated in configurator
     */
    uint8_t                                 dmas;
    #else // ifdef CY_IP_MXSMIF
    void* empty;
    #endif /* defined(CY_IP_MXSMIF) */
} mtb_hal_memoryspi_configurator_t;

/**
 * @brief RNG object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXCRYPTO_INSTANCES) || defined(CPUSS_CRYPTO_PRESENT) \
    || defined(CY_IP_M0S8CRYPTO) || defined(CY_IP_M0S8CRYPTOLITE)
    // Both m0s8crypto and mxcrypto share the same base type name
    CRYPTO_Type*                base;
    #elif defined(CY_IP_MXCRYPTOLITE)
    CRYPTOLITE_Type*            base;
    #else
    void* empty;
    #endif
} mtb_hal_trng_t;

/**
 * @brief TRNG configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef void* mtb_hal_trng_configurator_t;

/**
 * @brief RTC object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    void* empty;
} mtb_hal_rtc_t;

/**
 * @brief RTC configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    void* empty;
} mtb_hal_rtc_configurator_t;

#if defined(CY_IP_MXSDHC)

/**
 * Data transfer status on SDHC/SDIO
 */
typedef enum
{
    /** No data transfer in progress */
    _MTB_HAL_SDXX_NOT_RUNNING           = 0x0,
    /** Waiting for a command to complete */
    _MTB_HAL_SDXX_WAIT_CMD_COMPLETE     = 0x1,
    /** Waiting for a transfer to complete */
    _MTB_HAL_SDXX_WAIT_XFER_COMPLETE    = 0x2,
    /** Waiting for completion of both a command and a transfer */
    _MTB_HAL_SDXX_WAIT_BOTH             = _MTB_HAL_SDXX_WAIT_CMD_COMPLETE |
                                          _MTB_HAL_SDXX_WAIT_XFER_COMPLETE
} _mtb_hal_sdxx_data_transfer_status_t;

/**
 * Contains common members between SDHC and SDIO
 */
typedef struct
{
    bool                                  is_sdio;
    void*                                 obj;
    SDHC_Type*                            base;
    cy_stc_sd_host_context_t              context;
    const mtb_hal_clock_t*                clock;

    bool                                  emmc;
    cy_en_sd_host_dma_type_t              dma_type;
    uint32_t                              adma_descriptor_tbl[2];
    _mtb_hal_sdxx_data_transfer_status_t  data_transfer_status;

    mtb_hal_gpio_t                        pin_clk;
    mtb_hal_gpio_t                        pin_cmd;
    bool                                  low_voltage_io_set;

    uint32_t                              irq_cause;

    /* whether the block is configured by device-configurator (true)
     *  or by user via HAL API (false) */
    bool                                dc_configured;
    bool                                clock_owned;
} _mtb_hal_sdxx_t;

#endif /* defined(CY_IP_MXSDHC) */

/**
 * @brief SDHC object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSDHC)
    _mtb_hal_sdxx_t                     sdxx;
    cy_stc_sd_host_sd_card_config_t*    card_config;

    uint8_t                             bus_width;
    bool                                enable_led_control;
    /* TOUT setting of SDHC block */
    uint8_t                             data_timeout_tout;
    bool                                data_timeout_auto_reconfig;
    /* Desired by user data timeout in card clocks */
    uint32_t                            data_timeout_card_clocks_user;
    mtb_hal_gpio_t                      pin_data[8];
    bool                                low_voltage_io_desired;
    uint16_t                            emmc_generic_cmd6_time_ms;
    #else // if defined(CY_IP_MXSDHC)
    void* empty;
    #endif /* defined(CY_IP_MXSDHC) */
} mtb_hal_sdhc_t;

/**
 * @brief SDHC configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSDHC)
    SDHC_Type*                              base;
    const cy_stc_sd_host_init_config_t*     host_config;
    cy_stc_sd_host_sd_card_config_t*        card_config;
    const mtb_hal_clock_t*                  clock;
    struct
    {
        mtb_hal_gpio_t                      clk;
        mtb_hal_gpio_t                      cmd;
        mtb_hal_gpio_t                      data[8];
    } gpios;
    #else // if defined(CY_IP_MXSDHC)
    void* empty;
    #endif /* defined(CY_IP_MXSDHC) */
} mtb_hal_sdhc_configurator_t;

/**
 * @brief SDIO object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSDHC)
    _mtb_hal_sdxx_t                     sdxx;
    #elif defined(MTB_HAL_UDB_SDIO)
    mtb_hal_resource_inst_t             resource;
    mtb_hal_gpio_t                      pin_clk;
    mtb_hal_gpio_t                      pin_cmd;

    uint32_t                            irq_cause;
    #endif /* defined(MTB_HAL_IP_MXSDHC) */

    mtb_hal_event_callback_data_t       callback_data;

    #if defined(CY_IP_MXSDHC) || defined(MTB_HAL_UDB_SDIO)
    mtb_hal_gpio_t                      pin_data0;
    mtb_hal_gpio_t                      pin_data1;
    mtb_hal_gpio_t                      pin_data2;
    mtb_hal_gpio_t                      pin_data3;

    uint16_t                            block_size;

    uint32_t                            events;
    #else
    void* empty;
    #endif /* defined(CY_IP_MXSDHC) || defined(MTB_HAL_UDB_SDIO) */
} mtb_hal_sdio_t;

/**
 * @brief SDIO configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSDHC)
    SDHC_Type*                              base;
    const cy_stc_sd_host_init_config_t*     host_config;
    const mtb_hal_clock_t*                  clock;
    struct
    {
        mtb_hal_gpio_t                      clk;
        mtb_hal_gpio_t                      cmd;
        mtb_hal_gpio_t                      data[4];
    } gpios;
    #else // if defined(CY_IP_MXSDHC)
    void* empty;
    #endif /* defined(CY_IP_MXSDHC) */
} mtb_hal_sdio_configurator_t;

/**
 * @brief SPI object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                         base;
    const mtb_hal_clock_t*              clock;
    cy_stc_scb_spi_context_t*           context;
    uint16_t volatile                   pending;
    bool                                is_target;
    uint8_t                             data_bits;
    uint32_t                            irq_cause;
    uint8_t                             write_fill;
    void* rx_buffer;
    uint32_t                            rx_buffer_size;
    const void* tx_buffer;
    uint32_t                            tx_buffer_size;
    bool                                is_async;
    mtb_hal_event_callback_data_t       callback_data;
    #else // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    void* empty;
    #endif // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
} mtb_hal_spi_t;

/**
 * @brief SPI configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                             base;
    const mtb_hal_clock_t*                  clock;
    const cy_stc_scb_spi_config_t*          config;
    #else // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    void* empty;
    #endif /* defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB) */
} mtb_hal_spi_configurator_t;

/**
 * @brief SysPm callback data object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    cy_stc_syspm_callback_t        pdl_cb;
    cy_stc_syspm_callback_params_t cb_params;
    /* Actually a mtb_hal_syspm_callback_state_t, store as uint to avoid circular includes */
    uint32_t                       state;
    void*                          user_arg;
} mtb_hal_syspm_callback_data_t;

/**
 * @brief Timer object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #ifdef CY_IP_MXTCPWM
    mtb_hal_tcpwm_t                 tcpwm;
    mtb_hal_event_callback_data_t   callback_data;
    uint32_t                        callback_event;     //!< Event requested
    #if (_MTB_HAL_IRQ_MUXING)
    uint32_t                        clear_intr_mask;
    #endif /* (_MTB_HAL_IRQ_MUXING) */
    #else
    void* empty;
    #endif
} mtb_hal_timer_t;

/**
 * @brief Timer configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if (_MTB_HAL_DRIVER_AVAILABLE_TCPWM)
    TCPWM_Type*             tcpwm_base;
    #endif
    uint32_t                tcpwm_cntnum;
    const mtb_hal_clock_t*  clock;
} mtb_hal_timer_configurator_t;

#if defined(COMPONENT_MW_ASYNC_TRANSFER)
/** Function to handle the async transfer */
typedef cy_rslt_t (* async_transfer_handler_t)(void* obj, uint32_t event);
#endif // defined(COMPONENT_MW_ASYNC_TRANSFER)

/**
 * @brief UART object
 *
 * Application code should not rely on the specific contents of this struct.
 * They are considered an implementation detail which is subject to change
 * between platforms and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                         base;
    cy_stc_scb_uart_context_t*          context;
    const mtb_hal_clock_t*              clock;
    mtb_hal_event_callback_data_t       callback_data;
    uint32_t                            irq_cause;
    #if defined(COMPONENT_MW_ASYNC_TRANSFER)
    bool                                rts_enable;
    async_transfer_handler_t            async_handler;
    mtb_async_transfer_context_t*       async_ctx;
    mtb_async_transfer_event_callback_t async_event_callback;
    #endif // defined(COMPONENT_MW_ASYNC_TRANSFER)
    #else // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    void* empty;
    #endif // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
} mtb_hal_uart_t;


/**
 * @brief UART configurator struct
 *
 * This struct allows a configurator to provide block configuration information
 * to the HAL. Because configurator-generated configurations are platform
 * specific, the contents of this struct is subject to change between platforms
 * and/or HAL releases.
 */
typedef struct
{
    #if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    CySCB_Type*                             base;
    const mtb_hal_clock_t*                  clock;
    #if defined(COMPONENT_MW_ASYNC_TRANSFER)
    bool                                    rts_enable; //Sets if the Flow control is enabled and
                                                        //RTS is connected to a pin
    #endif // defined(COMPONENT_MW_ASYNC_TRANSFER)
    #else // if defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB)
    void* empty;
    #endif /* defined(CY_IP_MXSCB) || defined(CY_IP_MXS22SCB) */
} mtb_hal_uart_configurator_t;

#if defined(__cplusplus)
}
#endif /* __cplusplus */

/** \} group_hal_impl_hw_types */
/** \} group_hal_impl */
